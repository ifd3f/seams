use maud::{html, Markup, PreEscaped, DOCTYPE};

use crate::{
    model::{SiteData, SiteIndex, Webring},
    templates::{navbar::Navbar, util::RenderWebring},
};

/// Renders pages using the base template
#[derive(Clone)]
pub struct BaseRenderer<'a> {
    pub script_templates: Vec<String>,
    pub site_data: &'a SiteData,
    pub site_index: &'a SiteIndex<'a>,
}

impl BaseRenderer<'_> {
    pub fn render_page(&self, page: impl BaseTemplatePage) -> Markup {
        let (page_meta, rendered) = page.render_page(self.site_data, self.site_index);
        let navbar = Navbar {
            href: &page_meta.href,
            items: &self.site_data.navbar,
            navbar_path: &page_meta.navbar_path,
        };

        html! {
            (DOCTYPE)
            html {
                head {
                    title { (page_meta.title) }
                    link rel="stylesheet" type="text/css" href="/styles.css";
                    link
                        rel="alternate"
                        type="application/rss+xml"
                        title="RSS Feed for astrid.tech"
                        href="/feed.xml";

                    script type="text/javascript" src="/bundle.js" {}
                    meta name="viewport" content="width=device-width, initial-scale=1.0";
                    meta property="og:site_name" content="astrid dot tech";
                    (PreEscaped(&self.site_data.extra_head))
                    (page_meta.extra_head)
                }
                body {
                    div .site-container {
                        (navbar)
                        div { (rendered) }
                        div #script-templates style="display: none" {
                            @for st in &self.script_templates {
                                (PreEscaped(st))
                            }
                        }
                        (footer(self.site_data))
                    }
                }
            }
        }
    }
}

#[derive(Clone, Default, Debug)]
pub struct PageMeta {
    pub title: String,
    pub href: String,
    /// empty to refer to nothing
    pub navbar_path: Vec<String>,
    pub extra_head: Markup,
}

/// A page that uses the base template.
pub trait BaseTemplatePage {
    fn render_page(&self, sd: &SiteData, si: &SiteIndex<'_>) -> (PageMeta, Markup);
}

fn footer(sd: &SiteData) -> Markup {
    html! {
        footer .site-footer {
            @if sd.webrings.len() > 0 {
                section .webrings {
                    h2 { "Webrings" }
                    (webrings(sd.webrings.iter()))
                }
            }
            hr;
            div .copyright {
                p {
                    "Â© 2019-2024 Astrid Yu. Some rights reserved."
                }
                p {
                    "astrid.tech v3 was generated by "
                    a href="https://github.com/ifd3f/seams" { "seams, the seamingly silly CMS" } ". "
                    "Seams, in turn, was made by Astrid Yu with a generous helping of "
                    "tea and insomnia."
                }
                p {
                    "Seams is licensed under "
                    a href="https://www.gnu.org/licenses/agpl-3.0.en.html" { "AGPL-3.0-Only" } ". "
                    "The content of astrid.tech is licensed under "
                    a href="https://creativecommons.org/licenses/by-sa/4.0/" { "Creative Commons BY-SA 4.0" } ". "
                }
            }
            div {
                input #nsfw-switch type="checkbox";
                label for="nsfw-switch" {
                    "I am over 18 and am willing to see Not Safe for Work (NSFW) content."
                }
            }
        }
    }
}

fn webrings<'a>(wrs: impl IntoIterator<Item = &'a Webring>) -> Markup {
    html! {
        @for wr in wrs {
            (RenderWebring::from(wr))
        }
    }
}
